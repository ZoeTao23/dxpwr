---
title: "Sample Size Calculator"
author: "Xinya Tao"
format: pdf
editor: visual
---

#### PART 0: Plot and parameters calculation

```{r}
    
    ##----- (1) calculate params for binormal assumption  
      estimate_binorm_params <- function(AUC, ratio){
        
        #--------------------------#
        #  Calculate parameters for ROC curve follows a binormal distribution assumption 
        
        #  Args: 
        #    AUC: estimated areas under the ROC curve 
        #    Ratio: the ratio of standard deviations (Sx/Sy)  
        
        #  Returns: 
        #     a:
        #     b:  
        #--------------------------#  
        
        # validate inputs
        if (!is.numeric(AUC) || AUC <= 0.5 || AUC >= 1) {
          stop("AUC must be a numeric value between 0.5 and 1 (exclusive).")
        }
        
        if (!is.numeric(ratio) || ratio <= 0) {
          stop("Ratio must be a positive numeric value.")
        }
  
        # compute params
        b <- ratio
        a <- round(qnorm(AUC) * sqrt(1 + b^2),2)

        # output
        return(list(a = a, b = b))

      }

      
    ## test
      estimate_binorm_params(AUC=0.8, ratio=1)


    ##----- (2) plot AUC follows a binormal curve 
      plot_binorm_ROC <- function(a, b) {
  
        #--------------------------#
        #  plot AUC curve follows a binormal dist
        
        #  Args:
        #     a (>0; e.g., 0.8, 0.85, 0.9 etc.)
        #     b (>0; e.g., 1, 2, 3, etc.)
        
        #  Returns: 
        #     ROC curve  
        #--------------------------#  
        
        # load required packages 
        if (!requireNamespace("ggplot2", quietly = TRUE) || !requireNamespace("pROC", quietly = TRUE)) {
          stop("Packages 'ggplot2' and 'pROC' are required. Please install them first.")
        }
  
        # validate input 
        if (!is.numeric(a) || length(a) != 1) {
          stop("'a' must be a single numeric value.")
        }
          
        if (!is.numeric(b) || length(b) != 1 || b <= 0) {
          stop("'b' must be a single positive numeric value.")
        }
    
        # set seed for reproducibility
        set.seed(123)
    
        # generate binormal samples
        n <- 1000  
        controls <- rnorm(n, mean = 0, sd = 1)      
        cases <- rnorm(n, mean = a, sd = 1) 
    
        # construct response labels and scores
        labels <- factor(c(rep(0, n), rep(1, n)), levels = c(0, 1))  
        scores <- c(controls, cases)
    
        # compute ROC curve
        roc_obj <- pROC::roc(labels, scores)
    
        # compute AUC value
        auc_value <- pROC::auc(roc_obj)
    
        # create ROC plot
        pROC::ggroc(
                data        = roc_obj, 
                legacy.axes = TRUE, 
                color       = "tomato", 
                size        = 0.8
        ) +
        ggplot2::geom_abline(
                    slope     = 1, 
                    intercept = 0, 
                    linetype  = "dashed", 
                    color     = "darkgrey", 
                    size      = 0.8
        ) +
        ggplot2::ggtitle(paste0("ROC Curve (Binormal Distribution, a = ", a, ", b = ", b, ")")) +
        ggplot2::annotate(
          geom     = "text", 
          x        = 0.9, 
          y        = 0.0, 
          label    = paste0("AUC = ", round(auc_value, 3)), 
          size     = 4, 
          color    = "black", 
          fontface = "bold"
        ) +  
        ggplot2::theme_bw(base_size = 14) +
        ggplot2::theme(
          plot.title  = ggplot2::element_text(hjust = 0.5, face = "bold", size = 12),
          axis.title  = ggplot2::element_text(face = "bold"),
          axis.text   = ggplot2::element_text(size = 12)
      )
}

    # test
      plot_binorm_ROC(1.19,1)
      
    ##----- (3) sample size calculator    
      estimate_diagnostic_sample_size <- function(var_function, alpha=0.05, beta=NULL, delta, test_type){
  
        
        #--------------------------#
        #  Sample size calculator for diagnostic accuracy tests
        
        #  Args: 
        #     var_function: variance function 
        #     alpha: significant level
        #     beta: Type II error rate (1 - power) 
        #     delta: the desired length of one-half of the CI
        #     test_type: "one_diagnostic","multi_diagnostic","non_inferiority","equivalency"  
        
        #  Returns: 
        #     Sample size matrics
        
        #--------------------------#    
        
        
        # (1) ----- Validate inputs
        if (!is.numeric(alpha) || alpha <= 0 || alpha >= 1) {
          stop("alpha must be a numeric value between 0 and 1.")
        }
        
        if (!is.null(beta) && (!is.numeric(beta) || beta <= 0 || beta >= 1)) {
          stop("beta must be a numeric value between 0 and 1, or NULL.")
        }
        
        if (!is.numeric(delta) || delta <= 0) {
          stop("delta must be a positive numeric value.")
        }
        
        if (!is.character(test_type) || !(test_type %in% c("one_diagnostic", "multi_diagnostic", "inferiority", "equivalency"))) {
          stop("test_type must be one of 'one_diagnostic', 'multi_diagnostic', 'non_inferiority' or 'equivalency'.")
        }
  
        
        # (2) ----- Calculation module
        
        ## calculate critical value
        z_alpha <- qnorm(1 - alpha / 2)
        z_beta <- ifelse(is.null(beta), 0, qnorm(1 - beta))
  
        ## calculate sample size based on test type
        N_total <- switch(test_type,
                     "one_diagnostic" = {  
                       if (!is.numeric(var_function) || length(var_function) != 1) {
                          stop("For 'one_diagnostic', var_function must be a single numeric value.")
                        }
                        numerator <- ((z_alpha + z_beta) * sqrt(var_function))^2
                        ceiling(numerator / delta^2)
                    },
                    
                    "multi_diagnostic" = {  
                      if (!is.numeric(var_function) || length(var_function) != 2) {
                        stop("For 'multi_diagnostic', var_function must be a numeric vector of length 2.")
                      }
                      numerator <- (z_alpha * sqrt(var_function[1]) + z_beta * sqrt(var_function[2]))^2
                      ceiling(numerator / delta^2)
                    },
                    
                    "non_inferiority" = {  
                      if (!is.numeric(var_function) || length(var_function) != 1) {
                        stop("For 'non_inferiority', var_function must be a single numeric value.")
                      }
                      numerator <- (z_alpha + z_beta)^2 * var_function
                      ceiling(numerator / delta^2)
                    },
                    
                    "equivalency" = {  
                      if (!is.numeric(var_function) || length(var_function) != 1) {
                        stop("For 'equivalency', var_function must be a single numeric value.")
                      }
                      numerator <- (z_alpha + z_beta)^2 * var_function
                      ceiling(numerator / delta^2)
                    }
                      
                    stop("Invalid test type. Use 'one_diagnostic', 'multi_diagnostic', 'inferiority' or 'equivalency'.") 
  )

      #  (3) ----- Structured outputs
      return(N_total)

}


    # test
      estimate_diagnostic_sample_size(var_function = 0.8, alpha = 0.05, beta = 0.2, delta = 0.1, test_type = "one_diagnostic")
      estimate_diagnostic_sample_size(var_function = c(0.2, 0.3), alpha = 0.05, beta = 0.2, delta = 0.1, test_type = "multi_diagnostic")
      
      
      
      ##----- (4) adjust sample size by prevalence
 
    adjust_sample_by_prevalence <- function(sample, prev, beta) {
      
      
        #--------------------------#
        #  Adjust Sample size by prevalence (prospective study)
        
        #  Args: 
        #     sample: unadjusted sample size 
        #     prev: the prevalence of the condition in the population 
        #     beta: Type II error rate (1 - power) 
        
        #  Returns: 
        #     adjusted sample size
        
        #--------------------------# 
      
    
        #  (1) ----- Validate inputs
        if (!is.numeric(sample) || sample <= 0 || !(sample == round(sample))) {
          stop("initial sample must be an integer value more than 1.")
        }
      
        if (!is.numeric(prev) || prev <= 0 || prev >= 1) {
          stop("prevalence must be a numeric value between 0 and 1.")
        }
        
        if (!is.null(beta) && (!is.numeric(beta) || beta <= 0 || beta >= 1)) {
          stop("beta must be a numeric value between 0 and 1")
        }
        
    
        #  (2) ----- Calculation modules
        
        
        ## calculate critical value
        z_beta <- qnorm(beta)
         
        ## calculate quadratic equation coefficients 
        a <- prev^2
        b <- -2 * prev * sample - prev * (1 - prev) * z_beta^2
        c <- sample^2  
        
        # calculate revised sample size
        n_adjusted <- ceiling((-b + sqrt(b^2 - 4 * a * c)) / (2 * a))
        
        
        #  (3) ----- Structured outputs
        
        ## method reference
        method <- "Sample size adjusted method based on prevalence"
        
        structure(
          list(
            method = method,
            power = 1 - beta,
            prevalence = prevalence,
            adjusted_sample_size = n_revised
          ),
          class = "Sample Size Adjustment"
        )
          
      }
     
      # test
      adjust_sample_by_prevalence(sample=350,  prevalence=0.8, beta=0.9) 
    

      ##----- (5) adjust sample size for clustered data
      adjust_sample_for_cluster <- function(sample, avg_obs_per_patient, intra_corr, R = 1) {
      
        #--------------------------#
        #  Adjust Sample size for clustered data 
        
        #  Args: 
        #     sample: number of required samples if each patients had only one observation 
        #     avg_obs_per_patient: average number of observations per patient 
        #     intra_corr: average correlation between test results of observations from the same patient 
        #     R: the ratio of patients with and without the condition
        
        #  Returns: 
        #     adjusted sample size
        
        #--------------------------# 
        
        
        
        #  (1) ----- Validate inputs
        if (!is.numeric(sample) || sample <= 0 || !(sample == round(sample))) {
          stop("initial sample must be an integer value more than 1.")
        }
      
        if (!is.numeric(avg_obs_per_patient) || avg_obs_per_patient <= 1) {
          stop("avg_obs_per_patient must be a positive numeric value more than 1.")
        }
        
        if (!is.numeric(intra_corr) || intra_corr <= 0 || intra_corr >= 1) {
          stop("intra_corr must be a numeric value between 0 and 1")
        }
        
        if (!is.numeric(R) || R <= 0) {
          stop("R must be a positive numeric value.")
        }
  
        #  (2) ----- Calculation modules
        
        obs_required <- sample * (1 + (avg_obs_per_patient - 1) * intra_corr)
        n_required <- obs_required / avg_obs_per_patient
      
        n_with_condition <- ceiling(n_required / (1+R))
        n_without_condition <- ceiling(R * n_required / (1+R))   
        n_revised <- n_with_condition + n_without_condition
        
        
        #  (3) ----- Structured outputs
        
        ## method reference
        method <- "Sample size adjusted method for cluster data"
        
        structure(
          list(
            method = method,
            initial_sample_size = n_initial,
            avg_obs_per_patient = avg_obs_per_patient,
            intra_cluster_corr = intra_corr,
            revised_sample_size = n_revised,
            n_with_condition <- n_with_condition,
            n_without_condition <- n_without_condition   
            
          ),
          class = "Sample Size Adjustment"
        )
      
    }

    adjust_sample_for_cluster(sample = 46, avg_obs_per_patient = 1.5, intra_corr = 0.5)
    
    
    
    ##----- (5) adjust sample size by one test with fixed size 
    
    adjust_sample_by_fixed_group <- function(n_fixed_group, n_total) {
  
      #--------------------------#
      #  adjust sample size when sample size for one group is fixed (for unapired study design)  
      
      #  Args: 
      #     n_fixed_group: number of required samples if each patients had only one observation 
      #     n_total: expected total sample size  
      
      #  Returns: 
      #     sample size: (known group, unknown group, total)
      
      #--------------------------#   
      
      #  (1) ----- Validate inputs
      if (!is.numeric(n_fixed_group) || n_fixed_group <= 0 || !(n_fixed_group == round(n_fixed_group))) {
          stop("n_fixed_group must be an integer value more than 1.")
      }
      
      if (!is.numeric(n_total) || n_total <= 0 || !(n_total == round(n_total)) || n_total <= n_fixed_group) {
          stop("n_total must be an integer value larger than n_fixed_group.")
        }
      
      
      #  (2) ----- Calculation modules
      n_unknown_group <- ceiling((n_total*n_fixed_group) / (2*n_fixed_group - n_total) )
      n_total <- n_fixed_group + n_unknown_group 
        
      #  (3) ----- Structured outputs
  
      ## reference method
      method <- "Sample size method for comparing sensitivity/specificity by by Cohen (1977)"
  
      structure(
        list(
          method = method,
          N_total = n_total,
          n_test1 = n_fixed_group,
          n_test2 = n_unknown_group
        ),
        class = "Sample Size Adjustment"
      )
  
  
}
```

#### PART 1: Sample size estimation

##### (1) Estimate sensitivity/specificity

```{r}
    ##----- (1) calculate sensitivity/specificity (not closed to 1)   
      sample_estimate_sesp <- function(theta, alpha=0.05, beta=NULL, L){
  
        #--------------------------#
        #  Sample size calculation when estimating sensitivity or specificity 
        
        #  Args: 
        #     theta: expected sensitivity or specificity 
        #     alpha: significant level 
        #     beta: type II error rate (1 - power) 
        #     L: the desired length of one-half of the CI
        
        #  Returns: 
        #     sample size: (total)
        
        #--------------------------# 
        
        
        #  (1) ----- validate inputs 
         
        if (!is.numeric(theta) || theta <= 0 || theta >= 1) {
          stop("theta must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(alpha) || alpha <= 0 || alpha >= 1) {
          stop("alpha must be a numeric value between 0 and 1.")
        }
        
        if (!is.null(beta) && (!is.numeric(beta) || beta <= 0 || beta >= 1)) {
          stop("beta must be a numeric value between 0 and 1, or NULL.")
        }
        
        if (!is.numeric(L) || L <= 0 || L > 0.5 ) {
          stop("L must be a numeric value between 0 and 0.5.")
        } 
        
        #  (2) ----- Calculation modules
        
        ## calculate variance function 
        var_function <- theta*(1-theta)
        
        ## calculate sample size 
        N_total <- estimate_diagnostic_sample_size(
          var_function = var_function, 
          alpha = alpha, 
          beta = beta, 
          delta = L, 
          test_type = "one_diagnostic"
        )
        
        # method description
        
        #  (3) ----- Structured outputs
        
        ## method reference
        method <- "Sample size method for estimating sensitivity/specificity by Arkin and Wachtel (1990)"
        
        structure(
          list(
            alpha = alpha,
            power = ifelse(is.null(beta), "NULL", 1 - beta),
            method = method,
            sample_size = N_total
          ),
          class = "Single diagnostic test")

      }
  
      # test
      sample_one_sesp(theta = 0.8, alpha = 0.05, beta = 0.2, L = 0.05)
      sample_one_sesp(theta = 0.8, alpha = 0.05, L = 0.05)
      
      
    ##----- (2) calculate sensitivity/specificity (closed to 1)  
    
      
    ## add methods  
      
      
      
      
      
      
      
      
      
      
      
      
      
        
      
    ##----- (3) calculate sensitivity/specificity at fixed fpr
      sample_estimate_sesp_fixed_fpr <- function(A, b=1, fpr, alpha=0.05, beta=NULL, L, R=1, dist="binorm") {
    
        #--------------------------#
        #  Sample size calculation when estimating sensitivity or specificity at fixed fpr 
        
        #  Args: 
        #     A: expected area under the ROC curve
        #     b: the ratio of standard deviations (Sx/Sy) 
        #     fpr: false positive rate 
        #     alpha: significant level 
        #     beta: type II error rate (1 - power) 
        #     L: the desired length of one-half of the CI
        #     R: the ratio of patients with and without the condition
        #     dist: assumption, "binorm" and "obs_binorm" 
        
        #  Returns: 
        #     sample size: (with condition, without condition, total)
        
        #--------------------------# 
        
        
        #  (1) ----- validate inputs 
        if (!is.numeric(A) || A <= 0 || A >= 1) {
          stop("A must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(b) || b <= 0) {
          stop("b must be a positive numeric value.")
        }
        
        if (!is.numeric(fpr) || fpr <= 0 || fpr >= 1) {
          stop("A must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(alpha) || alpha <= 0 || alpha >= 1) {
          stop("alpha must be a numeric value between 0 and 1.")
        }
        
        if (!is.null(beta) && (!is.numeric(beta) || beta <= 0 || beta >= 1)) {
          stop("beta must be a numeric value between 0 and 1, or NULL.")
        }
        
        if (!is.numeric(L) || L <= 0 || L > 0.5) {
          stop("L must be a numeric value between 0 and 0.5.")
        } 
        
        if (!is.numeric(R) || R <= 0) {
          stop("R must be a positive numeric value.")
        }
        
        if (!is.character(dist) || !(dist %in% c("binorm", "obs_binorm"))) {
          stop("dist must be one of 'binorm' or 'obs_binorm'.")
        }
        
        
        #  (2) ----- calculation modules 
      
        ## calculate z-transform parameters
        g <- qnorm(fpr)
        a <- estimate_binorm_params(A, b)$a
        
        ## calculate variance function 
        if (dist == "binorm") {
      
          var_function <- 1 + b^2 / R + a^2 / 2 + g^2 * b^2 * (1 + R) / (2 * R)
          method <- "Sample size method for estimating sensitivity at fixed FPR from Obuchowski and McClish (1997)"
            
        } else if(dist == "obs_binorm") {
          
          var_function <- 1 + b^2 / R + a^2 / 2 + g^2 * b^2 * (1 + R) / (2 * R) + g * a * b
          method <- "Sample size method for estimating sensitivity at fixed FPR from Obuchowski and McClish (1997)"  
        
        } else {
          
          stop("Invalid 'dist' value. Use 'binorm' or 'obs_binorm'.")
          
        }
          
        ## calculate range of sensitivity  
        se0 <- pnorm(a + b * qnorm(fpr))
        a_lwr <- qnorm(se0 - L) - b * qnorm(fpr)
        a_upr <- qnorm(se0 + L) - b * qnorm(fpr)
        
        ## calculate range of Z-value and delta 
        z_lwr <- a_lwr + b * qnorm(fpr)
        z_upr <- a_upr + b * qnorm(fpr)
        z_delta <- (z_upr - z_lwr) / 2
        
        ## calculate sample size 
        n <- estimate_diagnostic_sample_size(
          var_function = var_function, 
          alpha = alpha, 
          beta = beta, 
          delta = z_delta, 
          test_type = "one_diagnostic"
          )
        
        ## calculate number of patients with and without the condition
        n_with_condition <- ceiling(n)
        n_without_condition <- ceiling(n*R)
        
        N_total <- n_with_condition + n_without_condition
         
        
        #  (3) ----- structured outputs 
        structure(
          list(
            alpha = alpha,
            power = ifelse(is.null(beta),"NULL",1-beta),
            method = method,
            sample_size = N_total,
            n_with_condition = n_with_condition,
            n_without_condition = n_without_condition
          ),
          class = "Single diagnostic test")
    
  }

    # test
      sample_sesp_fixed_fpr(A = 0.8, b = 1, fpr = 0.1, alpha = 0.05, beta = NULL, L = 0.1, R = 1, dist = "binorm")
      sample_sesp_fixed_fpr(A = 0.8, b = 1, fpr = 0.1, alpha = 0.05, beta = 0.2, L = 0.1, R = 1, dist = "binorm")
```

##### **(2) Estimate AUC (Full and partial )**

```{r}

    ##----- (1) calculate full AUC
      sample_estimate_full_ROC <- function(A, b=1, alpha=0.05, beta=NULL, L, R=1, dist="any") {
  
        #--------------------------#
        #  Sample size calculation when estimating full auc 
        
        #  Args: 
        #     A: expected area under the ROC curve
        #     b: the ratio of standard deviations (Sx/Sy) 
        #     alpha: significant level 
        #     beta: type II error rate (1 - power) 
        #     L: the desired length of one-half of the CI
        #     R: the ratio of patients with and without the condition
        #     dist: the premise assumption, must be one of "any", "exp", "binorm", "obs_binorm"  
        
        #  Returns: 
        #     sample size: (with condition, without condition, total)
        
        #--------------------------# 

   
        #  (1) ----- validate inputs 
        if (!is.numeric(A) || A <= 0 || A >= 1) {
          stop("A must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(b) || b <= 0) {
          stop("b must be a positive numeric value.")
        }
        
        if (!is.numeric(alpha) || alpha <= 0 || alpha >= 1) {
          stop("alpha must be a numeric value between 0 and 1.")
        }
        
        if (!is.null(beta) && (!is.numeric(beta) || beta <= 0 || beta >= 1)) {
          stop("beta must be a numeric value between 0 and 1, or NULL.")
        }
        
        if (!is.numeric(L) || L <= 0 || L > 0.5) {
          stop("L must be a numeric value between 0 and 0.5.")
        } 
        
        if (!is.numeric(R) || R <= 0) {
          stop("R must be a positive numeric value.")
        }
        
        if (!is.character(dist) || !(dist %in% c("any", "exp", "binorm", "obs_binorm"))) {
          stop("dist must be one of 'any', 'exp', 'binorm' or 'obs_binorm'.")
        }
        
      
        #  (2) ----- calculation modules 
        
        ## calculate variance function  
        var_function <- switch(
          dist,
          "any" = {
            method <- "Sample size method for estimating AUC by Blume (2009)"
            A * (1 - A)
          },
          "exp" = {
            method <- "Sample size method for estimating AUC by Hanley and McNeil (1982)"
            A / (2 - A) / R + 2 * A^2 / (1 + A) - A^2 * (1 / R + 1)
          },
          "binorm" = {
            method <- "Sample size method for estimating AUC by Obuchowski (1994)"
            a <- estimate_binorm_params(A, b)$a
            (0.0099) * exp(-a^2 / 2) * ((5 * a^2 + 8) + (a^2 + 8) / R)
          },
          "obs_binorm" = {
            method <- "Sample size method for estimating AUC by Obuchowski and McClish (1997)"
            a <- estimate_binorm_params(A, b)$a
            (0.0099) * exp(-a^2 / 2) * ((5 * a^2 + 8) + (a^2 + 8) / R) - 0.0398 * a^2 * exp(-a^2 / 2)
          },
          stop("Invalid 'dist' value. Use 'any', 'exp', 'binorm', or 'obs_binorm'.")
        )
        
        ## calculate sample size 
        n <- estimate_diagnostic_sample_size(
          var_function = var_function, 
          alpha = alpha, 
          beta = beta, 
          delta = L, 
          test_type = "one_diagnostic"
          )
        
        ## calculte number of patients with and without the condition
        if (dist == "any" & R < 1) {
          
          n_with_condition <- ceiling(n*R)
          n_without_condition <- ceiling(n)
          
        } else { 
          
          n_with_condition <- ceiling(n)
          n_without_condition <- ceiling(n*R)
        } 
      
        N_total <- n_with_condition + n_without_condition
        
        #  (3) ----- structured outputs   
        
        structure(
          list(
            alpha = alpha,
            power = ifelse(is.null(beta),"NULL",1 - beta),
            method = method,
            sample_size = N_total,
            n_with_condition = n_with_condition,
            n_without_condition = n_without_condition
          ),
          class = "Single diagnostic test")
 
}

    ## test 
      lapply(X = c("any", "exp", "binorm", "obs_binorm"), 
            FUN = function(dist) sample_estimate_full_ROC(A = 0.8, alpha = 0.05, beta = 0.2, L = 0.1, R = 1, dist = dist))

  
    ##----- (2) calculate patrial AUC 
      sample_estimate_partial_auc <- function(A, b=1, e1, e2, alpha=0.05, beta=NULL, L, R=1, dist="binorm") {
      
      
        #--------------------------#
        #  Sample size calculation when estimating patrial AUC
        
        #  Args: 
        #     A: expected area under the ROC curve
        #     b: the ratio of standard deviations (Sx/Sy) 
        #     e1: the lower bound of fpr
        #     e2: the upper bound of fpr
        #     alpha: significant level 
        #     beta: type II error rate (1 - power) 
        #     L: the desired length of one-half of the CI
        #     R: the ratio of patients with and without the condition
        #     dist: premise assumption, must be one of "binorm" and "obs_binorm"
        
        #  Returns: 
        #     sample size: (with condition, without condition, total)
        
        #--------------------------# 
      
        
        
        #  (1) ----- validate inputs 
        
        if (!is.numeric(A) || A <= 0 || A >= 1) {
          stop("A must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(b) || b <= 0) {
          stop("b must be a positive numeric value.")
        }
        
        if (!is.numeric(e1) || e1 <= 0 || e1 >= 1) {
          stop("e1 must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(e2) || e2 <= 0 || e2 >= 1) {
          stop("e2 must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(alpha) || alpha <= 0 || alpha >= 1) {
          stop("alpha must be a numeric value between 0 and 1.")
        }
        
        if (!is.null(beta) && (!is.numeric(beta) || beta <= 0 || beta >= 1)) {
          stop("beta must be a numeric value between 0 and 1, or NULL.")
        }
        
        if (!is.numeric(L) || L <= 0 || L > 0.5) {
          stop("L must be a numeric value between 0 and 0.5.")
        } 
        
        if (!is.numeric(R) || R <= 0) {
          stop("R must be a positive numeric value.")
        }
        
        if (!is.character(dist) || !(dist %in% c("binorm", "obs_binorm"))) {
          stop("dist must be one of 'binorm' or 'obs_binorm'.")
        }
        
        
        #  (2) ----- calculation modules 

    
        ## calculate parameters a, e', and e''
        a <- estimate_binorm_params(A, b)$a 
        e_prime <- (qnorm(c(e1,e2)) + a * b * (1+b^2)^(-1)) * sqrt(1 + b^2)
        e_double_prime <- (e_prime)^2 / 2 
          
        
        ## calculate variance function
        expr1 <- exp(-a^2 / 2 / (1 + b^2))
        expr2 <- 1 + b^2
        expr3 <- pnorm(e_prime[2]) - pnorm(e_prime[1])
        expr4 <- exp(-e_double_prime[1]) - exp(-e_double_prime[2])
          
        f <- expr1 * (2 * pi * expr2)^(-1 / 2) * expr3
        g <- expr1 * (2 * pi * expr2)^(-1) * expr4 - a * b * expr1 * (2 * pi * expr2^3)^(-1 / 2) * expr3
      
        var_function <- switch(
          dist,
          "binorm" = f^2 * (1 + b^2 / R + a^2 / 2) + g^2 * (b^2 * (1 + R) / (2 * R)),
          "obs_binorm" = f^2 * (1 + b^2 / R + a^2 / 2) + g^2 * (b^2 * (1 + R) / (2 * R)) + f * g * a * b,
          stop("Invalid 'dist' value. Use 'binorm' or 'obs_binorm'.")
        )
        
        ## calculate delta 
        delta <- (e1-e2)*L
        
        ## calculate sample size 
        n <- estimate_diagnostic_sample_size(
          var_function = var_function, 
          alpha = alpha, 
          beta = beta, 
          delta = delta, 
          test_type = "one_diagnostic"
          )
        
        ## calculate number of patients with and without condition
        n_with_condition <- ceiling(n)
        n_without_condition <- ceiling(n*R)
        N_total <- n_with_condition + n_without_condition 
        
        
        #  (3) ----- structured outputs 
        
        ## method reference  
        method <- "Sample size method for estimating partial AUC by Obuchowski and McClish (1997)"
        structure(
          list(
            alpha = alpha,
            power = ifelse(is.null(beta),"NULL",1-beta),
            method = method,
            sample_size = N_total,
            n_with_condition = n_with_condition,
            n_without_condition = n_without_condition
          ),
          class = "Single diagnostic test")
     }


    ## test
      sample_estimate_partial_auc(A = 0.8, e1 = 0, e2 = 0.1, b = 1, alpha = 0.05, beta, L = 0.1, R = 1, dist = "binorm")
 
 
    ##----- (3) AUC hypothesis testing
      sample_hypotest_auc <- function(A_null, A_alter, b=1, alpha=0.05, beta, alternative="two.sided", R=1) {
      
        #--------------------------#
        #  Sample size calculation when testing hypothesis that auc is equal to particular value
        
        #  Args: 
        #     A_null: AUC under the null hypothesis
        #     A_alter: AUC under the alternative hypothesis
        #     b: the ratio of standard deviations (Sx/Sy) 
        #     alpha: significant level 
        #     beta: type II error rate (1 - power) 
        #     alternative: alternative hypothesis, must be one of "less","greater","two-sided"
        #     R: the ratio of patients with and without the condition
        
        #  Returns: 
        #     sample size: (with condition, without condition, total)
        
        #--------------------------# 
    
        #  (1) ----- validate inputs 
        
        if (!is.numeric(A_null) || A_null <= 0 || A_null >= 1) {
          stop("A_null must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(A_alter) || A_alter <= 0 || A_alter >= 1) {
          stop("A_alter must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(b) || b <= 0) {
          stop("b must be a positive numeric value.")
        }
        
        if (!is.numeric(alpha) || alpha <= 0 || alpha >= 1) {
          stop("alpha must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(beta) || beta <= 0 || beta >= 1) {
          stop("beta must be a numeric value between 0 and 1.")
        }
        
        if (!is.character(alternative) || !(alternative %in% c("two.sided", "greater", "less"))) {
          stop("alternative must be one of 'two.sided', 'greater' or 'less'.")
        }
       
        if (!is.numeric(R) || R <= 0) {
          stop("R must be a positive numeric value.")
        }
        
        #  (2) ----- calculation modules 
  
        ## calculate variance function 
        a0 <- estimate_binorm_params(A_null, b)$a
        V0_theta <- (0.0099) * exp(-a0^2 / 2)*((5 * a0^2 + 8)+(a0^2 + 8) / R)
        
        aA <- estimate_binorm_params(A_alter, b)$a
        VA_theta <- (0.0099) * exp(-aA^2 / 2)*((5 * aA^2 + 8)+(aA^2 + 8) / R)
        
        var_function <- c(V0_theta, VA_theta)
        delta <- abs(A_null - A_alter)
        
        ## adjust alpha for alternative test
        alpha <- switch(
          alternative,
          "less" = 2 * alpha,
          "greater" = 2 * alpha,
          "two.sided" = alpha,
          stop("Invalid 'alternative' value. Use 'less', 'greater', or 'two.sided'.")
        )
        
        ## calculate sample size
        n <- estimate_diagnostic_sample_size(
          var_function = var_function, 
          alpha = alpha, 
          beta = beta, 
          delta = delta, 
          test_type = "multi_diagnostic"
          )
        
        ## calculate patients with and without condition 
        n_with_condition <- ceiling(n)
        n_without_condition <- ceiling(n*R)
        N_total <- n_with_condition + n_without_condition
  
        
        #  (3) ----- structured outputs
        
        ## method 
        method <- switch(
          alternative,
          "less" = paste0("Non-inferiority test: AUC < ",A_null),
          "greater" = paste0("Superiority test: AUC > ",A_null),
          "two.sided" = paste0("Equivalence test: AUC = ",A_null)  
        )
        
        structure(
          list(
            alpha = alpha,
            power = ifelse(is.null(beta),"NULL", 1 - beta),
            method = method,
            sample_size = N_total,
            n_with_condition = n_with_condition,
            n_without_condition = n_without_condition
          ),
          class = "Single diagnostic test")
      
    }
        
      sample_hypotest_auc(A_null = 0.5, A_alter = 0.8, alpha = 0.05, beta = NULL, alternative = "two.sided", R = 1)  
    
```

##### (3) Compare sensitivity/specificity

```{r}

    ##----- (1) compare the sensitivity/specificity of two tests
      sample_compare_sesp <- function(theta1, theta2, prob_t1pos_give_t2pos=NULL, alpha=0.05, beta, paired=FALSE) {
       
        
        #--------------------------#
        #  Sample size calculation when comparing test's sensitivity or specificity 
        
        #  Args: 
        #     theta1: the expected sensitivity (or specificity) of test1 
        #     theta2: the expected sensitivity (or specificity) of test2
        #     prob_t1pos_give_t2pos: probability that test 1 is positive given that test 2 is positive 
        #     alpha: significant level 
        #     beta: type II error rate (1 - power) 
        #     paired: paired study design or unpaired study design, must be "True" or "False"
        
        #  Returns: 
        #     sample size: (test1, test2, total)
        
        #--------------------------#   
        
        
        #  (1) ----- validate inputs 
        
        if (!is.numeric(theta1) || theta1 <= 0 ||theta1 >= 1) {
          stop("theta1 must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(theta2) || theta2 <= 0 || theta2 >= 1) {
          stop("theta2 must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(prob_t1pos_give_t2pos) || prob_t1pos_give_t2pos < 0 || prob_t1pos_give_t2pos > 1) {
          stop("prob_t1pos_give_t2pos must be a numeric value between 0 and 1(inclusive).")
        }
        
        if (!is.numeric(alpha) || alpha <= 0 || alpha >= 1) {
          stop("alpha must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(beta) || beta <= 0 || beta >= 1) {
          stop("beta must be a numeric value between 0 and 1.")
        }
        
        if (!is.logical(paired) || length(paired) != 1) {
          stop("'paired' must be a single logical value (TRUE or FALSE).")
        }
        
       
        #  (2) -----  calculation modules 
        
        message("null_hypothesis: theta_test1 = theta_test2")
        
        ## calculate variance fucntion 
        fi <- theta1 + theta2 - 2 * theta2 * prob_t1pos_give_t2pos 
        delta1 <- theta1 - theta2
        
        V0_delta_theta <- fi
        VA_delta_theta <- fi - delta1^2
        
        var_function <- c(V0_delta_theta, VA_delta_theta)
        
        ## calculate sample size 
        n <- estimate_diagnostic_sample_size(
          var_function = var_function, 
          alpha = alpha, 
          beta = beta, 
          delta = delta1, 
          test_type = "multi_diagnostic")
        
        ## calculate number of patients for each test 
        n_test1 <- n_test2 <- ceiling(n/2)
        N_total <- n_test1 + n_test2 
        
        
        #  (3) ----- structured outputs 
        
        ## method reference
        method <- "Sample size method for comparing tests' sensitivity/specificity by Beam (1992)"
        
        structure(
          list(
            alpha = alpha,
            power = ifelse(is.null(beta), "NULL", 1-beta),
            method = paste0(method, ifelse(paired, "- Paired", "- Unpaired")),
            sample_size = N_total,
            n_test1 = n_test1,
            n_test2 = n_test2
          ),
            class = "Two diagnostic tests")
      
      }
      
      ## test
      sample_cmp_sesp(theta1 = 0.8, theta2 = 0.7, prob_t1pos_give_t2pos, alpha = 0.05, beta = 0.2, delta = 0.1, paired = FALSE)


      sample_cmp_sesp(theta1 = 0.8, theta2 = 0.7, prob_t1pos_give_t2pos = 1, alpha = 0.05, beta = 0.2, delta = 0.1, paired = TRUE)




    ##----- (2) compare the ppv/npv of two tests (补充unpaired方法)
      sample_compare_ppvnpv <- function(metric="PPV", theta2, p, alpha=0.05, beta, gamma, delta, paired=TRUE, alternative="two.sided") {
        
        #--------------------------#
        #  Sample size calculation when comparing test's positive/negative predictive values 
        
        #  Args:
        #     metric: index to be compared between two diagnostic tests, must be one of "PPV" or "NPV"  
        #     theta2: the expected NPV (or PPV) of test2 
        #     alpha: significant level 
        #     beta: type II error rate (1 - power)
        #     p: the proportion vector with 8 elements: 
        #       for patients without the condition, 
        #         p1: the pr of patients (test1 +, test2 +);
        #         p2: the pr of patients (test1 +, test2 -);
        #         p3: the pr of patients (test1 -, test2 +);
        #         p4: the pr of patients (test1 -, test2 -). 
        #       for patients with the condition, 
        #         p5: the pr of patients (test1 +, test2 +); 
        #         p6: the pr of patients (test1 +, test2 -); 
        #         p7: the pr of patients (test1 -, test2 +); 
        #         p8: the pr of patients (test1 -, test2 -).
        #     gamma: a specific value of interest for rPPV/rNPV under the alternative hypothesis (gamma > 0)
        #     delta: a specific value of interest in the null hypothesis (In most cases, let delta = 1).
        #     paired: paired study design or unpaired study design, must be "True" or "False"
        
        
        #  Returns: 
        #     sample size: (test1, test2, total)
        
        #--------------------------# 
        
        #  (1) ----- validate inputs 
        
        if (!metric %in% c("PPV", "NPV")) {
          stop("'metric' must be either 'PPV' or 'NPV'.")
        }
        
        if (!is.numeric(theta2) || theta2 <= 0 || theta2 >= 1) {
          stop("'theta2' must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(p) || length(p) != 8 || any(p < 0 | p > 1)) {
          stop("'p' must be a numeric vector of length 8 with values between 0 and 1.")
        }
        
        if (!is.numeric(alpha) || alpha <= 0 || alpha >= 1) {
          stop("'alpha' must be a numeric value between 0 and 1 .")
        }
        
        if (!is.numeric(beta) || beta <= 0 || beta >= 1) {
          stop("'beta' must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(gamma) || gamma <= 0) {
          stop("'gamma' must be a positive numeric value.")
        }
        
        if (!is.numeric(delta) || delta <= 0) {
          stop("'delta' must be a positive numeric value.")
        }
        
        if (!is.logical(paired) || length(paired) != 1) {
          stop("'paired' must be a single logical value (TRUE or FALSE).")
        }
        
        if (!alternative %in% c("less", "greater", "two.sided")) {
          stop("'alternative' must be one of 'less', 'greater', or 'two.sided'.")
        }
        
        
        #  (2) -----  calculation modules
        null_hypothesis <- switch(
          alternative,
          "less" = paste0("null hypothesis: r", metric," > ", delta),
          "greater" = paste0("null hypothesis: r", metric, " < ", delta),
          "two.sided" = paste0("null hypothesis: r", metric, " = ", delta)  
        )
        message(print(null_hypothesis))  
        
        
        ## adjust alpha for one-sided or two-sided test
        alpha <- switch(
          alternative,
          "less" = 2 * alpha,
          "greater" = 2 * alpha,
          "two.sided" = alpha,
          stop("Invalid 'alternative' value. Use 'less', 'greater', or 'two.sided'.")
        )
        
        ## calculate critical values 
        z_alpha <- qnorm(1 - alpha / 2) 
        z_beta <- qnorm(1 - beta)
        
        ## calculate sample size
        if(metric == "PPV") {
          
          m1 <- ((z_alpha + z_beta) / log10(gamma / delta))^2
          m2 <- ((p[5] + p[6]) * (p[5] + p[7])) ^ (-1)
          m3 <- 2 * (p[7] + p[3]) * gamma * theta2^2 +
                (p[5] * (1 - gamma) - p[6]) * theta2 +
                p[6] + p[7] * (1 - 3 * gamma * theta2)
            
        } else if(metric == "NPV") {
          
          m1 <- ((z_alpha + z_beta)^2 / log10(gamma / delta))^2
          m2 <- ((p[2] + p[4]) * (p[3] + p[4])) ^ (-1)
          m3 <- -2 * (p[4] + p[8]) * gamma * theta2^2 +
                (-p[3] + p[4] - gamma * (p[2] - p[4])) * theta2 +
                p[2] + p[3]
        } else {
          stop("Invalid 'choice' value. Use 'PPV' or 'NPV'.")
        }
        
        ## calculate patients in each test
        n <- ceiling(m1*m2*m3)
        n_test1 <- n_test2 <- ceiling(n/2)
        N_total <- n_test1 + n_test2 
        
        
        #  (3) ----- structured outputs 
        
        ## method reference
        method <- "Sample size method for comparing test's positive/negative predictive values by Moskowize and Pepe(2006)"
        
        structure(
          list(
            alpha = alpha,
            power = ifelse(is.null(beta),"NULL",1-beta),
            method = paste0(method, ifelse(paired, "- Paired", "- Unpaired")),,
            sample_size = N_total,
            n_test1 = n_test1,
            n_test2 = n_test2
          ),
          class = "Two diagnostic tests"
        )
        
      }
      
        ## test
        sample_compare_ppvnpv(theta2 = 0.8, p = c(0.4,0,0.52,0.44,0.7,0,0.1,0.2), alpha = 0.05, beta = 0.2, delta = 1, gamma = 1.1, paired = TRUE, metric = "PPV", alternative = "two.sided")

        
        
        

    ##----- (3) compare the sensitivity/specificity at fixed fpr

      sample_compare_sesp_fixed_fpr <- function(A_null, b_null=1, A1_alter, b1_alter=1, A2_alter, b2_alter=1, fpr, rN=NULL, rD=NULL, alpha=0.05, beta, paired=TRUE, R=1) {
        
        #--------------------------#
        #  Sample size calculation when comparing test's sensitivity or specificity at fixed fpr 
        
        #  Args: 
        #     A_null: AUC under the null hypothesis 
        #     b_null: the ratio of standard deviations under the null hypothesis 
        #     A1_alter: AUC of test 1 under the alternative hypothesis 
        #     b1_alter: the ratio of standard deviations of test 1 under the alternative hypothesis 
        #     A2_alter: AUC of test 2 under the alternative hypothesis 
        #     b2_alter: the ratio of standard deviations of test 2 under the alternative hypothesis
        #     rD: the correlation of the underlying bivariate binormal distribution for patients with the condition
        #     rN: the correlation of the underlying bivariate binormal distribution for patients without the condition
        #     alpha: significant level 
        #     beta: type II error rate (1 - power) 
        #     paired: paired study design or unpaired study design, must be "True" or "False"
        #     R: the ratio of patients with and without the condition
        
        #  Returns: 
        #     sample size: (test1 with condition, test1 without condition, test2 with condition, test 2 without condition, total)
        
        #--------------------------#  
        
        
        #  (1) ----- validate inputs 
        if (!is.numeric(A_null) || A_null <= 0 ||A_null >= 1) {
          stop("A_null must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(A1_alter) || A1_alter <= 0 ||A1_alter >= 1) {
          stop("A1_alter must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(A2_alter) || A2_alter <= 0 ||A2_alter >= 1) {
          stop("A2_alter must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(b_null) || b_null <= 0) {
          stop("b_null must be a positive numeric value.")
        }
        
        if (!is.numeric(b1_alter) || b1_alter <= 0) {
          stop("b1_alter must be a positive numeric value.")
        }
        
        if (!is.numeric(b2_alter) || b2_alter <= 0) {
          stop("b2_alter must be a positive numeric value.")
        }
        
        if (!is.null(rD) || (!is.numeric(rD) || rD < -1 || rD > 1)) {
          stop("rD must be a numeric value between -1 and 1.")
        }
        
        if (!is.null(rN) || (!is.numeric(rN) || rN < -1 || rN > 1)) {
          stop("rN must be a numeric value between -1 and 1.")
        }
        
        if (!is.numeric(alpha) || alpha <= 0 || alpha >= 1) {
          stop("alpha must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(beta) || beta <= 0 || beta >= 1) {
          stop("beta must be a numeric value between 0 and 1.")
        }
        
        if (!is.logical(paired) || length(paired) != 1) {
          stop("'paired' must be a single logical value (TRUE or FALSE).")
        }
        
        if (!is.numeric(R) || R <= 0) {
          stop("R must be a positive numeric value.")
        }
        
        
        #  (2) ----- calculation modules
        
        ## assign empirical correlation 
        if(paired){
          
          rN <- ifelse(is.null(NULL), 0.5, rN)
          rD <- ifelse(is.null(NULL), 0.5, rD)
            
        } else {
          r <- 0
          rN <- rD <- r
        }
        
        
        ## calcuate variance function 
        a1_alter <- estimate_binorm_params(A1_alter, b1_alter)$a
        a2_alter <- estimate_binorm_params(A2_alter, b2_alter)$a
        
        z1_alter <- a1_alter + b1_alter * qnorm(fpr)
        z2_alter <- a2_alter + b2_alter * qnorm(fpr)
        
        V_theta <- function(a, b, e, R) {
          
          g <- qnorm(e)
          V <- 1 + b^2 / R + a^2 / 2 + g^2 * (b^2) * (1 + R) / (2 * R)
          
          return(V)  
        }
          
        C_delta_theta <- function(a1, a2, b1, b2, e, rD, rN) {
          
          g <- qnorm(e)
          C <- rD + (rN * b1 * b2) / R + (rD^2 * a1 * a2) / 2 + g ^ 2 * b1 * b2 * (rN^2 + R * rD^2) / (2 * R) + g* rD^2 * (a1 * b2 + a2 * b1) / 2
          
          return(C)
        }
        
        V01 <- V02 <- V_theta(a_null, b_null, e, R)
        VA1 <- 1 + V_theta(a1_alter, b1_alter, e, R)
        VA2 <- 1 + V_theta(a2_alter, b2_alter, e, R)
        
        C0 <- C_delta_theta(a_null, a_null, b_null, b_null, e, rD, rN)
        CA <- C_delta_theta(a1_alter, a2_alter, b1_alter, b2_alter, e, rD, rN)
        
        V0 <- V01 + V02 - 2*C0
        VA <- VA1 + VA2 - 2*CA
        
        
        ## calculate delta 
        delta1 <- abs(z1_alter - z2_alter)
        
        
        ## calculate sample size with and without condition 
        n <- estimate_diagnostic_sample_size(
          var_function = var_function, 
          alpha = alpha, 
          beta = beta, 
          delta = delta1, 
          test_type = "multi_diagnostic"
          )
        
        n_test1_with_conditon <- ceiling(n/2)
        n_test1_without_conditon <- ceiling(R*n/2)
        n_test2_with_conditon <- ceiling(n/2)
        n_test2_without_conditon <- ceiling(R*n/2)
        
        N_total <- 2 * (n_test1_with_conditon + n_test1_without_conditon)
        
        #  (3) ----- structured outputs
       
        ## method reference
        method <- "Sample size method for comparing Tests' sensitivity/specificity at fixed fpr by Obuchowski and 
McClish (1997)"
        
        structure(
          list(
            alpha = alpha,
            power = ifelse(is.null(beta),"NULL",1-beta),
            method = paste0(method, ifelse(paired,"- Paired","- Unpaired")),
            sample_size = N_total,
            n_test1_with_conditon = n_test1_with_conditon,
            n_test1_without_conditon = n_test1_without_conditon,
            n_test2_with_conditon = n_test2_with_conditon,
            n_test2_without_conditon = n_test2_without_conditon,
          ),
          class = "Two diagnostic tests")
        
        
      }

```

##### (4) Compare AUC (full and partial)

```{r}

    ##----- (1) compare the full AUC of two tests
      sample_compare_full_roc <- function(A_null, b_null=1, A1_alter, b1_alter=1, A2_alter, b2_alter=1, r=NULL, rN=NULL, rD=NULL, alpha=0.05, beta, R=1, paired=FALSE, dist="any") {
        
        #--------------------------#
        #  Sample size calculation when comparing test's full AUC 
        
        #  Args: 
        #     A_null: AUC under the null hypothesis 
        #     b_null: the ratio of standard deviations under the null hypothesis 
        #     A1_alter: AUC of test 1 under the alternative hypothesis 
        #     b1_alter: the ratio of standard deviations of test 1 under the alternative hypothesis 
        #     A2_alter: AUC of test 2 under the alternative hypothesis 
        #     b2_alter: the ratio of standard deviations of test 2 under the alternative hypothesis
        #     rD: the correlation of the underlying bivariate binormal distribution for patients with the condition
        #     rN: the correlation of the underlying bivariate binormal distribution for patients without the condition
        #     alpha: significant level 
        #     beta: type II error rate (1 - power) 
        #     paired: paired study design or unpaired study design, must be "True" or "False"
        #     R: the ratio of patients with and without the condition
        #     dist: the assumption of the method, must be one of 'any' or 'binorm'.
        
        #  Returns: 
        #     sample size: (test1 with condition, test1 without condition, test2 with condition, test 2 without condition, total)
        
        #--------------------------#
        
        
        #  (1) ----- validate inputs 
        if (!is.numeric(A_null) || A_null <= 0 ||A_null >= 1) {
          stop("A_null must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(A1_alter) || A1_alter <= 0 ||A1_alter >= 1) {
          stop("A1_alter must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(A2_alter) || A2_alter <= 0 ||A2_alter >= 1) {
          stop("A2_alter must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(b_null) || b_null <= 0) {
          stop("b_null must be a positive numeric value.")
        }
        
        if (!is.numeric(b1_alter) || b1_alter <= 0) {
          stop("b1_alter must be a positive numeric value.")
        }
        
        if (!is.numeric(b2_alter) || b2_alter <= 0) {
          stop("b2_alter must be a positive numeric value.")
        }
        
        if (!dist %in% c("any", "binorm")) {
          stop("'dist' must be one of 'any', or 'binorm'.")
        }
        
        if (!is.logical(paired) || length(paired) != 1) {
          stop("'paired' must be a single logical value (TRUE or FALSE).")
        }
        
        if (!is.null(r) || (!is.numeric(r) || r < -1 || r > 1)) {
          stop("r must be a numeric value between -1 and 1.")
        }
        
        if (!is.null(rD) || (!is.numeric(rD) || rD < -1 || rD > 1)) {
          stop("rD must be a numeric value between -1 and 1.")
        }
        
        if (!is.null(rN) || (!is.numeric(rN) || rN < -1 || rN > 1)) {
          stop("rN must be a numeric value between -1 and 1.")
        }
        
        if (!is.numeric(alpha) || alpha <= 0 || alpha >= 1) {
          stop("alpha must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(beta) || beta <= 0 || beta >= 1) {
          stop("beta must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(R) || R <= 0) {
          stop("R must be a positive numeric value.")
        }
        
        
    
        
        #  (2) ----- calculation modules
    
        message("null hypothesis: A1 = A2 = ", A1)
     
        ## define correlation coefficients for paired and unpaired designs
        if(paired){
          
          rN <- ifelse(is.null(NULL), 0.5, rN)
          rD <- ifelse(is.null(NULL), 0.5, rD)
          
        } else {
          r <- 0
          rN <- rD <- r
        }
        
        ## calculate variance function 
        if(dist == "any") { 
         
          V0_delta_A <- 2 * A1_alter * (1 - A1_alter) - 2 * r * sqrt(A1_alter^2 * (1-A1_alter)^2)
          VA_delta_A <- A1_alter * (1 - A1_alter) + A2_alter * (1 - A2_alter) - 2 * r * sqrt(A1_alter * (1-A1_alter) * A2_alter * (1-A2_alter))
          
          var_function <- c(V0_delta_A, VA_delta_A)
          method <- "Sample size method for comparing Tests' AUC  by Beam (1992)"
          
        } else if(dist == "binorm") {
          
          a_null <- estimate_binorm_params(A_null, b_null)$a
          a1_alter <- estimate_binorm_params(A1_alter, b1_alter)$a 
          a2_alter <- estimate_binorm_params(A2_alter, b2_alter)$a 
          
          VA <- function(a) {
            
            V <- (0.0099) * exp(-a^2 / 2) * ((5 * a^2 + 8) + (a^2 + 8) / R)
            return(V)
          } 
          
          v0_A1 <- v0_A2 <- VA(a_null)
          VA_A1 <- VA(a1_alter)
          VA_A2 <- VA(a2_alter)
          
          C_delta_A <- function(a1, a2, rD, rN, R) {
            
            term1 <- exp(-(a1^2 + a2^2) / 4) / 12.5664 * (rD + rN / R + rD^2* a1 * a2 / 2)
            term2 <- exp(-(a1^2 + a2^2) / 4) / 50.2655 * a1 * a2 * (rN^2 + R* rD^2) / 2 / R
            term3 <- - exp(-(a1^2+a2^2) / 4) / 25.1327 * rD^2 * a1 * a2
            
            C <- term1 + term2 + term3
            return(C)
          }
          
          C0_delta_A <- ifelse(paired, C_delta_A(a_null, a_null, rD, rN, R), 0)
          CA_delta_A <- ifelse(paired, C_delta_A(a1_alter, a2_alter, rD, rN, R), 0)
          
          V0_delta_A <- v0_A1 + v0_A2 - 2 * C0_delta_A
          VA_delta_A <- vA_A1 + vA_A2 - 2 * CA_delta_A
          
          var_function <- c(V0_delta_A, VA_delta_A)
          method <- "Sample size method for comparing Tests' AUC by Obuchowski and McClish (1992)"
        } 
        
        ## calculate delta
        delta1 <- abs(A1_alter - A2_alter)
        
        ## calculate sample size with and without condition 
        n <- estimate_diagnostic_sample_size(
          var_function = var_function, 
          alpha = alpha, 
          beta = beta, 
          delta = delta1, 
          test_type = "multi_diagnostic"
          )
        
        n_test1_with_conditon <- ceiling(n/2)
        n_test1_without_conditon <- ceiling(R*n/2)
        n_test2_with_conditon <- ceiling(n/2)
        n_test2_without_conditon <- ceiling(R*n/2)
        
        N_total <- 2 * (n_test1_with_conditon + n_test1_without_conditon)
        
        
        #  (3) ----- structured outputs
        
        structure(
          list(
            alpha = alpha,
            power = ifelse(is.null(beta), "NULL", 1-beta),
            method = paste0(method, ifelse(paired,"- Paired","- Unpaired")),
            sample_size = N_total,
            n_test1_with_conditon = n_test1_with_conditon,
            n_test1_without_conditon = n_test1_without_conditon,
            n_test2_with_conditon = n_test2_with_conditon,
            n_test2_without_conditon = n_test2_without_conditon,
          ),
          class = "Two diagnostic tests")
      }
    
    
    ## test
    sample_compare_full_roc(A1 = 0.8, A2 = 0.9, alpha = 0.05, beta = 0.2, R = 1, paired = FALSE, dist = "any")
    sample_compare_full_roc(A1 = 0.8, A2 = 0.9, alpha = 0.05, beta = 0.2, R = 1, paired = FALSE, dist = "binorm")
    
    sample_compare_full_roc(A1 = 0.8, A2 = 0.9, alpha = 0.05, beta = 0.2, R = 1, paired = TRUE, dist = "any")
    sample_compare_full_roc(A1 = 0.8, A2 = 0.9, alpha = 0.05, beta = 0.2, R = 1, paired = TRUE, dist = "binorm") # the precision of a 

    

    ##----- (2) compare the partial test
      sample_compare_partial_roc <- function(A_null, b_null=1, A1_alter, A2_alter, b1_alter=1, b2_alter=1, e1, e2, alpha=0.05, beta, R=1, paired=FALSE) {
       
        
        #--------------------------#
        #  Sample size calculation when comparing test's partial AUC 
        
        #  Args: 
        #     A_null: AUC under the null hypothesis 
        #     b_null: the ratio of standard deviations under the null hypothesis 
        #     A1_alter: AUC of test 1 under the alternative hypothesis 
        #     b1_alter: the ratio of standard deviations of test 1 under the alternative hypothesis 
        #     A2_alter: AUC of test 2 under the alternative hypothesis 
        #     b2_alter: the ratio of standard deviations of test 2 under the alternative hypothesis
        #     e1: the lower bound of fpr
        #     e2: the upper bound of fpr
        #     rD: the correlation of the underlying bivariate binormal distribution for patients with the condition
        #     rN: the correlation of the underlying bivariate binormal distribution for patients without the condition
        #     alpha: significant level 
        #     beta: type II error rate (1 - power) 
        #     paired: paired study design or unpaired study design, must be "True" or "False"
        #     R: the ratio of patients with and without the condition
        #     dist: 
        
        #  Returns: 
        #     sample size: (test1 with condition, test1 without condition, test2 with condition, test 2 without condition, total)
        #--------------------------#
        
        #  (1) ----- validate inputs 
        if (!is.numeric(A_null) || A_null <= 0 ||A_null >= 1) {
          stop("A_null must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(A1_alter) || A1_alter <= 0 ||A1_alter >= 1) {
          stop("A1_alter must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(A2_alter) || A2_alter <= 0 ||A2_alter >= 1) {
          stop("A2_alter must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(b_null) || b_null <= 0) {
          stop("b_null must be a positive numeric value.")
        }
        
        if (!is.numeric(b1_alter) || b1_alter <= 0) {
          stop("b1_alter must be a positive numeric value.")
        }
        
        if (!is.numeric(b2_alter) || b2_alter <= 0) {
          stop("b2_alter must be a positive numeric value.")
        }
        
        if (!dist %in% c("any", "binorm")) {
          stop("'dist' must be one of 'any', or 'binorm'.")
        }
        
        if (!is.logical(paired) || length(paired) != 1) {
          stop("'paired' must be a single logical value (TRUE or FALSE).")
        }
        
        if (!is.null(r) || (!is.numeric(r) || r < -1 || r > 1)) {
          stop("r must be a numeric value between -1 and 1.")
        }
        
        if (!is.null(rD) || (!is.numeric(rD) || rD < -1 || rD > 1)) {
          stop("rD must be a numeric value between -1 and 1.")
        }
        
        if (!is.null(rN) || (!is.numeric(rN) || rN < -1 || rN > 1)) {
          stop("rN must be a numeric value between -1 and 1.")
        }
        
        if (!is.numeric(alpha) || alpha <= 0 || alpha >= 1) {
          stop("alpha must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(beta) || beta <= 0 || beta >= 1) {
          stop("beta must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(R) || R <= 0) {
          stop("R must be a positive numeric value.")
        }
        

        
        #  (2) ----- calculation modules
   
        message("null hypothesis: A1 = A2 = ", A1, "when fdr is between (",e1,",",e2,")")
        
        ## define the correlation
        if(paired){
          
          rN <- ifelse(is.null(rN), 0.5, rN)
          rD <- ifelse(is.null(rD), 0.5, rD)
        
        } else if(!paired) {
          r <- 0
          rN <- rD <- r
        }
        
        ## calculate variance function  
        f <- function(a, b, e1, e2){
          
          e_prime <- (qnorm(c(e1,e2)) + a * b / (1 + b^2 )) * sqrt(1 + b^2)
          
          expr1 <- exp(-a^2 / 2 / (1 + b^2)) 
          expr2 <- 1 + b^2
          expr3 <- pnorm(e_prime[2]) - pnorm(e_prime[1])
          
          f_value <- expr1 * (2 * pi * expr2) ^ (-1/2) * expr3
          return(f_value)
          
        }
        
        
        g <- function(a, b, e1, e2){
          
          e_prime <- (qnorm(c(e1,e2)) + a * b / (1 + b^2)) * sqrt(1 + b^2)
          e_double_prime <- (e_prime)^2 / 2 
          
          expr1 <- exp(-a^2 / 2 / (1 + b^2)) 
          expr2 <- 1 + b^2
          expr3 <- pnorm(e_prime[2]) - pnorm(e_prime[1])
          expr4 <- exp(-e_double_prime[1]) - exp(-e_double_prime[2])
          
          g_value <- expr1 * (2 * pi * expr2)^(-1) * expr4 - a * b* expr1 * (2 * pi * expr2^3)^(-1/2) * expr3
          return(g_value)
          
        }
        
        
        VA <- function(a, b, e1, e2) {
          
          f <- f(a, b, e1, e2)
          g <- g(a, b, e1, e2) 
          V <- f^2 * (1 + b^2 / R + a^2 / 2) + g^2 * (b^2 * (1+R) / 2 / R)
          
          return(V)
        } 
        
        C_delta_A <- function(a1, a2, b1, b2, e1, e2, rN, rD) {
          
          f1 <- f(a1, b1, e1, e2)
          f2 <- f(a2, b2, e1, e2)
          g1 <- g(a1, b1, e1, e2)
          g2 <- g(a2, b2, e1, e2)
          
          term1 <- f1 * f2 * (rD + rN * b1 * b2 / R + rD^2 * a1 * a2 / 2) + 
          term2 <- g1 * g2 * b1 * b2 * (rN^2 + R * rD^2) / 2 / R 
          term3 <- f1 * g2 * rD^2 * a1 * b2 / 2 
          term4 <- f2 * g1 * rD^2 * a2 * b1  
          
          C <- term1 + term2 + term3 + term4
          return(C)
          
        }
        
        a_null <- estimate_binorm_params(A_null, b_null)$a
        a1_alter <- estimate_binorm_params(A1_alter, b1_alter)$a
        a2_alter <- estimate_binorm_params(A2_alter, b2_alter)$a
        
        f_null <- f(a_null, b_null, e1, e2)
        g_null <- g(a_null, b_null, e1, e2)
        f1 <- f(a1_alter, b1_alter, e1, e2)
        g1 <- g(a1_alter, b1_alter, e1, e2)
        f2 <- f(a2_alter, b2_alter, e1, e2)
        g2 <- g(a2_alter, b2_alter, e1, e2) 
        
        
        ## calculate variance function 
        V0_A1 <- V0_A2 <- VA(a_null, b_null, e1, e2) 
        C0_delta_A <- C_delta_A(a1, a2, b1, b2, e1, e2, rN, rD)  
        V0_delta_A <- V0_A1 + V0_A2 - 2 * C0_delta_A
        
        VA_A1 <- VA(a1_alter, b1_alter, e1, e2)
        VA_A2 <- VA(a2_alter, b2_alter, e1, e2)
        CA_delta_A <- C_delta_A(a1_alter, a2_alter, b1_alter, b2_alter, e1, e2, rN, rD)
        VA_delta_A <- VA_A1 + VA_A2 - 2 * CA_delta_A
        
        var_function <- c(V0_delta_A, VA_delta_A)
        
        ## calculate delta 
        fpr <- function(a, b, x) {
          e <- pnorm(a + b * qnorm(x))
          return(e)
        }
        
        delta1 <- integrate(function(x) fpr(x, a1_alter, b1_alter), e1, e2)$value - 
           integrate(function(x) fpr(x, a2_alter, b2_alter), e1, e2)$value
        

        ## calculate sample size
        n <- estimate_diagnostic_sample_size(
          var_function = var_function, 
          alpha = alpha, 
          beta = beta, 
          delta = delta1, 
          test_type = "multi_diagnostic"
          )
        
        
        ## calculate sample size with and without condition 
        n_test1_with_condition <- ceiling(n/2)
        n_test1_without_condition <- ceiling(n/2*R) 
        n_test2_with_condition <- ceiling(n/2)
        n_test2_without_condition <- ceiling(n/2*R)
        
        N_total <- 2*(n_test1_with_condition + n_test1_without_condition)
        
        
        #  (3) ----- structured outputs
        method <- "Sample size method for comparing tests' patial AUC by Obuchowski and McClish (1997)"
        
        structure(
          list(
            alpha = alpha,
            power = ifelse(is.null(beta),"NULL",1 - beta),
            method = method,
            design = ifelse(paired,"paired design","unpaired design"),
            sample_size = N_total,
            n_test1_with_condition = n_test1_with_condition,
            n_test1_without_condition = n_test1_without_condition,
            n_test2_with_condition = n_test2_with_condition,
            n_test2_without_condition = n_test2_without_condition
          ),
          class = "Two diagnostic tests")
        
      }
    
        sample_compare_partial_roc(e1 = 0, e2 = 0.2, A1 = 0.8, A2 = 0.9, b1 = 1, b2 = 1, alpha = 0.05, beta = 0.2, paired = FALSE)
        sample_compare_partial_roc(e1 = 0, e2 = 0.2, A1 = 0.8, A2 = 0.9, b1 = 1, b2 = 1, alpha = 0.05, beta = 0.2, paired = TRUE)
```

##### (5) Assess inferiority

```{r}

    ##----- (1) assess the sens/spec of a new test is non-inferior to an existing test
      sample_non_inferior_sesp <- function(theta1, theta2, prob_t1pos_give_t2pos=NULL, delta, alpha=0.05, beta, R=1, paired=TRUE) {
      
      
        #--------------------------#
        #  Sample size calculation when testing the sensitivity/specificity of a new test (test1) is non-inferior to an existing test (test2)
        
        #  Args: 
        #     theta1: the expected sensitivity (or specificity) of test1 
        #     theta2: the expected sensitivity (or specificity) of test2
        #     prob_t1pos_give_t2pos: probability that test 1 is positive given that test 2 is positive 
        #     alpha: significant level 
        #     beta: type II error rate (1 - power) 
        #     delta: the smallest unacceptable difference in accuracy 
        #     paired: paired study design or unpaired study design, must be "True" or "False"
        
        
        #  Returns: 
        #     sample size: (test1, test2, total)
        #--------------------------#
      
    
        #  (1) ----- validate inputs 
        
        if (!is.numeric(theta1) || theta1 <= 0 ||theta1 >= 1) {
          stop("theta1 must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(theta2) || theta2 <= 0 || theta2 >= 1) {
          stop("theta2 must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(prob_t1pos_give_t2pos) || prob_t1pos_give_t2pos < 0 || prob_t1pos_give_t2pos > 1) {
          stop("prob_t1pos_give_t2pos must be a numeric value between 0 and 1(inclusive).")
        }
        
        if (!is.numeric(alpha) || alpha <= 0 || alpha >= 1) {
          stop("alpha must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(beta) || beta <= 0 || beta >= 1) {
          stop("beta must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(delta) || beta <= 0 || beta >= 1) {
          stop("delta must be a numeric value between 0 and 1.")
        }
        
        if (!is.logical(paired) || length(paired) != 1) {
          stop("'paired' must be a single logical value (TRUE or FALSE).")
        }
        
       
        #  (2) -----  calculation modules 
        
        message(paste0("null_hypothesis: theta_test1 - theta_test2 ≥ ", delta))
        message(paste0("alternative_hypothesis: theta_test1 - theta_test2 < ", delta))
        
        ## calculate variance fucntion 
        V0_delta_theta <- theta1 + theta2 - 2 * theta2 * prob_t1pos_give_t2pos 
        VA_delta_theta <- V0_delta_theta - (theta1 - theta2)^2
        
        var_function <- VA_delta_theta
        
        ## calculate delta
        delta <- abs(theta1 - theta2 - delta)
        
        ## calculate sample size 
        n <- estimate_diagnostic_sample_size(
          var_function = var_function, 
          alpha = alpha, 
          beta = beta, 
          delta = delta, 
          test_type = "non_inferiority")
        
        ## calculate number of patients for each test 
        if (paired) {
          n_with_condition <- ceiling(n)
          n_without_condition <- ceiling(R*n)
          N_total <- n_with_condition + n_without_condition 
          
        } else {
          n_test1_with_condition <- n_test2_with_condition <- ceiling(n)
          n_test1_without_condition <- n_test2_without_condition <- ceiling(R*n)
          N_total <- 2*(n_test1_with_condition + n_test1_without_condition) 
        }
        
        
        #  (3) ----- structured outputs 
        
        ## method reference
        method <- "Sample size method for testing whether se/sp of a new test is non-inferior to an existing test"
        
        if (paired) {
          
          structure(
            list(
              alpha = alpha,
              power = ifelse(is.null(beta), "NULL", 1-beta),
              method = paste0(method, "- Paired"),
              sample_size = N_total,
              n_test1 = n_with_condition,
              n_test2 = n_without_condition
            ),
              class = "Non-inferiority test")
          
        } else{
          
          structure(
            list(
              alpha = alpha,
              power = ifelse(is.null(beta),"NULL",1-beta),
              method = paste0(method, "- Unpaired"),
              sample_size = N_total,
              n_test1_with_condition = n_test1_with_condition,
              n_test1_without_condition = n_test1_without_condition,
              n_test2_with_condition = n_test2_with_condition,
              n_test2_without_condition = n_test2_without_condition,
            ),
            class = "Non-inferiority test") 
        }
    
    }
    
    
    ##----- (2) assess the auc of a new test is non-inferior to an existing test
      sample_non_inferiority_auc <- function(A1, A2, r=NULL, delta, alpha=0.05, beta, R=1, paired=TRUE) {
      
        #--------------------------#
        #  Sample size calculation when testing the auc of a new test (test1) is non-inferior to an existing test (test2)
        
        #  Args: 
        #     A1_alter: the expected auc of test1 
        #     A2_alter: the expected auc of test1 
        #     r: the correlation between the tests because of the paired design
        #     alpha: significant level 
        #     beta: type II error rate (1 - power) 
        #     paired: paired study design or unpaired study design, must be "True" or "False"
        #     R: the ratio of patients with and without the condition
        
        #  Returns: 
        #     sample size: (test1 with condition, test1 without condition, test2 with condition, test 2 without condition, total)
        #--------------------------#
      
    
        #  (1) ----- validate inputs 
        if (!is.numeric(A1) || A1 <= 0 ||A1 >= 1) {
          stop("A1 must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(A2) || A2 <= 0 ||A2 >= 1) {
          stop("A2 must be a numeric value between 0 and 1.")
        }
        
        if (!is.logical(paired) || length(paired) != 1) {
          stop("'paired' must be a single logical value (TRUE or FALSE).")
        }
        
        if (!is.null(r) || (!is.numeric(r) || r < -1 || r > 1)) {
          stop("r must be a numeric value between -1 and 1.")
        }
        
        if (!is.numeric(alpha) || alpha <= 0 || alpha >= 1) {
          stop("alpha must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(beta) || beta <= 0 || beta >= 1) {
          stop("beta must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(R) || R <= 0) {
          stop("R must be a positive numeric value.")
        }
        
  
        #  (2) ----- calculation modules
    
        message("null_hypothesis: AUC_test1 - AUC_test2 ≥ ", delta)
        message("alternative_hypothesis: AUC_test1 - AUC_test2 < ", delta)
        
        ## define correlation coefficients for paired and unpaired designs
        if(paired){
          r <- ifelse(is.null(NULL), 0.5, rD)
        } else {
          r <- 0
        }
        
        ## calculate variance function
        VA_delta_A <- A1 * (1 - A1) + A2 * (1 - A2) - 2 * r * sqrt(A1 * (1-A1) * A2 * (1-A2))
        var_function <- VA_delta_A
        
        ## calculate delta
        delta <- abs(A1 - A2 - delta)
        
        ## calculate sample size 
        n <- estimate_diagnostic_sample_size(
          var_function = var_function, 
          alpha = alpha, 
          beta = beta, 
          delta = delta, 
          test_type = "non_inferiority"
          )
        
        ## calculate sample size with and without condition
        if (paired) {
          n_with_condition <- ceiling(n)
          n_without_condition <- ceiling(R * n)
          N_total <- n_with_condition + n_without_condition 
          
        } else {
          n_test1_with_condition <- n_test2_with_condition <- ceiling(n)
          n_test1_without_condition <- n_test2_without_condition <- ceiling(R * n)
          N_total <- 2*(n_test1_with_condition + n_test1_without_condition) 
        }
        
        
        #  (3) ----- structured outputs
        method <- "Sample size method for testing whether auc of a new test is non-inferior to an existing test"
        
        if (paired) {
          
          structure(
            list(
              alpha = alpha,
              power = ifelse(is.null(beta), "NULL", 1-beta),
              method = paste0(method, "- Paired"),
              sample_size = N_total,
              n_test1 = n_with_condition,
              n_test2 = n_without_condition
            ),
              class = "Non-inferiority test")
          
        } else{
          
          structure(
            list(
              alpha = alpha,
              power = ifelse(is.null(beta),"NULL",1-beta),
              method = paste0(method, "- Unpaired"),
              sample_size = N_total,
              n_test1_with_condition = n_test1_with_condition,
              n_test1_without_condition = n_test1_without_condition,
              n_test2_with_condition = n_test2_with_condition,
              n_test2_without_condition = n_test2_without_condition,
            ),
            class = "Non-inferiority test") 
        }
      
    }
    
```

##### (6) Access Equivalency

```{r}
    
    ##----- (1) assess the sens/spec of a new test is equivalent to an existing test
      sample_equivalence_sesp <- function(theta1, theta2, prob_t1pos_give_t2pos=NULL, delta, alpha=0.05, beta, R=1, paired=TRUE) {
      
        #--------------------------#
        #  Sample size calculation when testing the sensitivity/specificity of a new test (test1) is equivalent to an existing test (test2)
        
        #  Args: 
        #     theta1: the expected sensitivity (or specificity) of test1 
        #     theta2: the expected sensitivity (or specificity) of test2
        #     prob_t1pos_give_t2pos: probability that test 1 is positive given that test 2 is positive 
        #     alpha: significant level 
        #     beta: type II error rate (1 - power) 
        #     delta: the smallest unacceptable difference in accuracy 
        #     paired: paired study design or unpaired study design, must be "True" or "False"
        
        
        #  Returns: 
        #     sample size: (test1, test2, total)
        #--------------------------#
      
    
        #  (1) ----- validate inputs 
        
        if (!is.numeric(theta1) || theta1 <= 0 ||theta1 >= 1) {
          stop("theta1 must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(theta2) || theta2 <= 0 || theta2 >= 1) {
          stop("theta2 must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(prob_t1pos_give_t2pos) || prob_t1pos_give_t2pos < 0 || prob_t1pos_give_t2pos > 1) {
          stop("prob_t1pos_give_t2pos must be a numeric value between 0 and 1(inclusive).")
        }
        
        if (!is.numeric(alpha) || alpha <= 0 || alpha >= 1) {
          stop("alpha must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(beta) || beta <= 0 || beta >= 1) {
          stop("beta must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(delta) || delta <= 0 || delta >= 1) {
          stop("delta must be a numeric value between 0 and 1.")
        }
        
        if (!is.logical(paired) || length(paired) != 1) {
          stop("'paired' must be a single logical value (TRUE or FALSE).")
        }
        
       
        #  (2) -----  calculation modules 
        
        message(paste0("null_hypothesis: theta_test1 - theta_test2 ≤ ", -delta, " or theta_test1 - theta_test2 ≥ ", delta))
        message(paste0("alternative_hypothesis: ", -delta, " < theta_test1 - theta_test2 <", delta))
        
        
        ## calculate variance fucntion 
        V0_delta_theta <- theta1 + theta2 - 2 * theta2 * prob_t1pos_give_t2pos 
        VA_delta_theta <- V0_delta_theta - (theta1 - theta2)^2
        
        var_function <- VA_delta_theta
        
        
        ## calculate delta
        if(theta1 - theta2 > 0) {
          
          delta <- abs(delta - (theta1 - theta2))
          
        } else if (theta1 - theta2 < 0) {
          
          delta <- abs(delta + (theta1 - theta2))
          
        } else if (theta1 - theta2 == 0){
          
          beta = beta / 2
          delta <- delta
          
        }
        
        ## calculate sample size 
        n <- estimate_diagnostic_sample_size(
          var_function = var_function, 
          alpha = alpha, 
          beta = beta, 
          delta = delta, 
          test_type = "equivalence")
        
        
        ## calculate number of patients for each test 
        if (paired) {
          n_with_condition <- ceiling(n)
          n_without_condition <- ceiling(R * n)
          N_total <- n_with_condition + n_without_condition 
          
        } else {
          n_test1_with_condition <- n_test2_with_condition <- ceiling(n)
          n_test1_without_condition <- n_test2_without_condition <- ceiling(R * n)
          N_total <- 2 * (n_test1_with_condition + n_test1_without_condition) 
          
        }
        
        
        #  (3) ----- structured outputs 
        
        ## method reference
        method <- "Sample size method for testing whether se/sp of a new test is non-inferior to an existing test"
        
        if (paired) {
          
          structure(
            list(
              alpha = alpha,
              power = ifelse(is.null(beta), "NULL", 1-beta),
              method = paste0(method, "- Paired"),
              sample_size = N_total,
              n_test1 = n_with_condition,
              n_test2 = n_without_condition
            ),
              class = "Non-inferiority test")
          
        } else{
          
          structure(
            list(
              alpha = alpha,
              power = ifelse(is.null(beta),"NULL",1-beta),
              method = paste0(method, "- Unpaired"),
              sample_size = N_total,
              n_test1_with_condition = n_test1_with_condition,
              n_test1_without_condition = n_test1_without_condition,
              n_test2_with_condition = n_test2_with_condition,
              n_test2_without_condition = n_test2_without_condition,
            ),
            class = "Non-inferiority test") 
        }
     
    }
  

    ##----- (2) assess the auc of a new test is equivalent to an existing test
      sample_equivalence_sesp <- function(A1, A2, r=NULL, delta, alpha=0.05, beta, R=1, paired=TRUE) {
      
        #--------------------------#
        #  Sample size calculation when testing the sensitivity/specificity of a new test (test1) is equivalent to an existing test (test2)
        
        #  Args: 
        #     theta1: the expected sensitivity (or specificity) of test1 
        #     theta2: the expected sensitivity (or specificity) of test2
        #     prob_t1pos_give_t2pos: probability that test 1 is positive given that test 2 is positive 
        #     alpha: significant level 
        #     beta: type II error rate (1 - power) 
        #     delta: the smallest unacceptable difference in accuracy 
        #     paired: paired study design or unpaired study design, must be "True" or "False"
        
        
        #  Returns: 
        #     sample size: (test1, test2, total)
        #--------------------------#
      
    
        #  (1) ----- validate inputs 
        
        if (!is.numeric(A1) || A1 <= 0 ||A1 >= 1) {
          stop("A1 must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(A2) || A2 <= 0 || A2 >= 1) {
          stop("A2 must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(r) || r < -1 || r > 1) {
          stop("r must be a numeric value between -1 and 1.")
        }
        
        if (!is.numeric(alpha) || alpha <= 0 || alpha >= 1) {
          stop("alpha must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(beta) || beta <= 0 || beta >= 1) {
          stop("beta must be a numeric value between 0 and 1.")
        }
        
        if (!is.numeric(delta) || delta <= 0 || delta >= 1) {
          stop("delta must be a numeric value between 0 and 1.")
        }
        
        if (!is.logical(paired) || length(paired) != 1) {
          stop("'paired' must be a single logical value (TRUE or FALSE).")
        }
        
       
        #  (2) -----  calculation modules 
        
        message(paste0("null_hypothesis: theta_test1 - theta_test2 ≤ ", -delta, " or theta_test1 - theta_test2 ≥ ", delta))
        message(paste0("alternative_hypothesis: ", -delta, " < theta_test1 - theta_test2 <", delta))
        
        
        ## calculate variance fucntion 
        VA_delta_theta <- A1*(1-A1)+A2*(1-A2)-2*r*sqrt(A1*(1-A1)*A2*(1-A2))
        var_function <- VA_delta_theta
        
        
        ## calculate delta
        if(A1 - A2 > 0) {
          
          delta <- abs(delta - (A1 - A2))
          
        } else if (theta1 - theta2 < 0) {
          
          delta <- abs(delta + (A1 - A2))
          
        } else if (A1 - A2 == 0){
          
          beta = beta / 2
          delta <- delta
          
        }
        
        ## calculate sample size 
        n <- estimate_diagnostic_sample_size(
          var_function = var_function, 
          alpha = alpha, 
          beta = beta, 
          delta = delta, 
          test_type = "Equivalence")
        
        
        ## calculate number of patients for each test 
        if (paired) {
          n_with_condition <- ceiling(n)
          n_without_condition <- ceiling(R * n)
          N_total <- n_with_condition + n_without_condition 
          
        } else {
          n_test1_with_condition <- n_test2_with_condition <- ceiling(n)
          n_test1_without_condition <- n_test2_without_condition <- ceiling(R * n)
          N_total <- 2 * (n_test1_with_condition + n_test1_without_condition) 
          
        }
        
        
        #  (3) ----- structured outputs 
        
        ## method reference
        method <- "Sample size method for testing whether auc of a new test is equivalent to an existing test"
        
        if (paired) {
          
          structure(
            list(
              alpha = alpha,
              power = ifelse(is.null(beta), "NULL", 1-beta),
              method = paste0(method, "- Paired"),
              sample_size = N_total,
              n_test1 = n_with_condition,
              n_test2 = n_without_condition
            ),
              class = "Equivalent test")
          
        } else{
          
          structure(
            list(
              alpha = alpha,
              power = ifelse(is.null(beta),"NULL",1-beta),
              method = paste0(method, "- Unpaired"),
              sample_size = N_total,
              n_test1_with_condition = n_test1_with_condition,
              n_test1_without_condition = n_test1_without_condition,
              n_test2_with_condition = n_test2_with_condition,
              n_test2_without_condition = n_test2_without_condition,
            ),
            class = "Equivalent test") 
        }
     
    }
    



    



```
